namespace BLL
open DAL.Models
open DAL.Models
open DAL.Models
open ViewModels
open DAL.Repositories


module Monads =
    type Result<'TSuccess,'TFailure> =
    | Success of 'TSuccess
    | Failure of 'TFailure
    
    
    type SuccessMonad () =
        member this.Bind(x, f) =
            match x with
            | Success s -> f s
            | Failure error -> Failure error
            
        member this.Return(x) =
                Success x
        
                      
    type MaybeBuilder () =
            member this.Bind(x, f) =
                    match x with
                    | Some s -> f s
                    | None -> None
                   
                    
            member this.Return(x) =
                Some x    
module Crypto =
    open System
    open System.Security.Cryptography

    let private subkeyLength = 32
    let private saltSize = 16

    /// Hashes a password by a specified number of iterations using the PBKDF2 crypto function.
    let hash password iterations =
        use algo = new Rfc2898DeriveBytes(password, saltSize, iterations)
        let salt = algo.Salt
        let bytes = algo.GetBytes(subkeyLength)
        
        let iters = if BitConverter.IsLittleEndian then BitConverter.GetBytes(iterations) else BitConverter.GetBytes(iterations) |> Array.rev

        let parts = Array.zeroCreate<byte> 54
        Buffer.BlockCopy(salt, 0, parts, 1, saltSize)
        Buffer.BlockCopy(bytes, 0, parts, 17, subkeyLength)
        Buffer.BlockCopy(iters, 0, parts, 50, sizeof<int>)

        Convert.ToBase64String(parts)

    /// Hashes a password using 10,000 iterations of the PBKDF2 crypto function.
    let fastHash password = hash password 10000

    /// Hashes a password using 100,000 iterations of the PBKDF2 crypto function.
    let strongHash password = hash password 100000

    /// Hashes a password using 300,000 iterations of the PBKDF2 crypto function.
    let uberHash password = hash password 300000

    /// Verifies a PBKDF2 hashed password with a candidate password.
    /// Returns true if the candidate password is correct.
    /// The hashed password must have been originally generated by one of the hash functions within this module.
    let verify hashedPassword (password:string) =
        let parts = Convert.FromBase64String(hashedPassword)
        if parts.Length <> 54 || parts.[0] <> byte 0 then
            false
        else
            let salt = Array.zeroCreate<byte> saltSize
            Buffer.BlockCopy(parts, 1, salt, 0, saltSize)

            let bytes = Array.zeroCreate<byte> subkeyLength
            Buffer.BlockCopy(parts, 17, bytes, 0, subkeyLength)

            let iters = Array.zeroCreate<byte> sizeof<int>
            Buffer.BlockCopy(parts, 50, iters, 0, sizeof<int>);

            let iters = if BitConverter.IsLittleEndian then iters else iters |> Array.rev

            let iterations = BitConverter.ToInt32(iters, 0)

            use algo = new Rfc2898DeriveBytes(password, salt, iterations)
            let challengeBytes = algo.GetBytes(32)

            match Seq.compareWith (fun a b -> if a = b then 0 else 1) bytes challengeBytes with
            | v when v = 0 -> true
            | _ -> false     
        
module RegisterLogic =
    open Monads
    let private userRepo = new UserRepo()
   
    let private Validate(model)(statement:bool)(errorMessage:string) =
        if statement
            then
                model|>Success
            else
                Failure errorMessage
    
    let private ValidateModel (model:SignUpViewModel) =
        let success = new SuccessMonad()
        success{
            let! hasName = Validate model (model.Name<>null) "Name must be"
            let! hasEmail = Validate hasName (model.Email<>null) "Email must be"
            let! hasPassword = Validate hasEmail (model.Password<>null) "Password must be"
            let! passwordMatch = Validate hasPassword (model.Password=model.ConfirmPassword) "Password does not match"
            let! passwordLength = Validate passwordMatch (model.Password.Length>=8 && model.Password.Length<=32) "Password length should be between 8 and 32 symbols"
            let! userNameLength = Validate passwordLength (model.Name.Length<=32) "Username length should be less than 32 symbols"
            let! freeUserName = Validate userNameLength (userRepo.GetUserByPk(model.Name)=null) "Username already taken"
            return freeUserName
        }
        
    let private CreateUser (model:SignUpViewModel) =
        try
            let user = new User()
            user.Email <- model.Email
            user.Password <-  Crypto.strongHash model.Password
            user.Username <- model.Name
            user.Role <- "User"
            user |> Success
        with
        |_->Failure "Could not create user( Try again later"
        
    let private AddUser(user:User) =
        try
            user |> userRepo.AddUser |> Success
        with
        |_->Failure "Could not create user( Try again later"
        
    type UserOrError(_user:Result<User,string>) =
        let user:User =
            match _user with
            | Success s -> s
            | Failure f -> null
        let errorMessage:string =
            match _user with
            | Success s -> null
            | Failure f -> f
        
        member this.GetUser =
            user
        member this.GetErrorMessage =
            errorMessage    
    let Register (signUpModel:SignUpViewModel) =
        let success = new SuccessMonad()
        let user = success{
                let! validatedModel = ValidateModel signUpModel
                let! inMemoryUser = CreateUser validatedModel
                let! user = AddUser inMemoryUser
                return user
            }
        new UserOrError(user)

module LogInLogic =
    let private userRepo = new UserRepo()
    
    let private UserNameCheck(model:LogInViewModel) =
        let user = userRepo.GetUserByPk(model.Name)
        match user with
        |null -> None
        |_->Some user
    let private PasswordCheck (user:User) (password:string) =
        let isPasswordRight = Crypto.verify user.Password password
        if isPasswordRight
            then
                user|>Some
            else
                None
    
    let  GetUser (model:LogInViewModel) =
        let maybe = new Monads.MaybeBuilder()
        let user = maybe{
            let! user = UserNameCheck model
            let! rightUser = PasswordCheck user model.Password
            return rightUser
        }
        
        match user with
        | Some s -> s
        | None -> null
     

